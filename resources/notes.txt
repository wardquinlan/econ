If we overflow gridline array, we get an array out of bounds.  Should probably fix this.

We might also want to add a new column to TIME_SERIES:

LAST_MERGED TIMESTAMP;

We just update each series with the last merge time.  It can be NULL for backwards compatibility purposes.

- while statement - and BREAK and CONTINUE
X allow the writing of const's if they are the same value
  => too many use cases esp. considering TimeSeries objects
X rewrite assert() and exitif() as es functions (?)
  => risky b.c. of use in test scripts.  I removed exitif().

Think about reintroducing ReturnResult. (For now, I only return int's from top level.)  Not sure which is best.
=> I already have Return.  I think I can just return Return from Evaluator.evaluate().  And then in Main, see if I get a Return or another object.
=> shouldn't in theory be that big a deal

try / catch => Test

The catch is a bit like a function call in that it takes a single 'parameter'. And it should have its own child symbol table.

includes => ??

Can simply do at the Evaluation level, not at the Tokenizer level.  We don't have to worry about if () because there is no change of scope in an if statement.  It has to be done at evaluation because the include might be an expression, which has to be evaluated.  In a way, then, it is a bit like calling a function.
=> basically, at evaluation time, we have to evaluate the include expression so we know what to include, then
we have to instantiate a new parser/tokenizer/evaluator, passing the current symbol table, and then run the evaluation.
=> I also thought maybe the parser could call the evaluator just on the include expression.  But that won't work.  It might
be a string that was evaluated in previous code.
=> So -> all of this has to be done at evaluation time
=> Evaluator just loads and evaluates the include using the *current* symbol table, not a child symbol table.  A bit like an IF statement

New Function, taking var # of args:

:Iterate(fn, arg1, arg2, ...);

Where fn is:

function fn(arg) {
}

=> Calls fn for each argument

Also => I can now probably re-write :Assert() as ES:Assert()

